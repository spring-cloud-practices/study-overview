= Spring Cloud Study
Daeho Oh
:doctype: book
:icons: font
:toc:
:toclevels: 4
:sectlinks:
:sectnums:
:webfonts: Noto+Sans+KR&display=swap
:stylesheet:


[[Chapter1_클라우드_네이티브_애플리케이션]]
== 클라우드 네이티브 애플리케이션
* 아마존 사례 41p

 아마존닷컴은 일체형 애플리케이션으로 시작했지만, 시간이 지남에 따라 동일한 일체형 애플리케이션 운영에 점점 더 많은 팀이 관여하게 되었으며, 이로 인해 코드베이스의 책임 한계와 소유권이 점점 더 불투명해지기 시작했다. 데이터베이스 처럼 공유되는 자원이 전체적인 비즈니스 확장을 어렵게 만든다. 애플리케이션 서버든 데이터베이스든 공유되는 자원이 늘어날수록, 운영 중인 애플리케이션에 기능을 추가할 때 개발팀이 가질 수 있는 제어권은 축소 된다. 42p

* 플랫폼의 약속 44p
+
--
** 아이디어 44p

 소프트웨어 컴포넌트들을 격리시키면 시스템의 일부를 더 빠르고 독립적으로 전달할 수 있게 된다.

** 제약 조건 45p

 소프트웨어 컴포넌트는 독립적으로 배포 가능한 서비스로 만들어져야 한다.

 서비스 안에 있는 모든 비즈니스 로직과 데이터는 캡슐화되어야 한다.

 서비스 외부에서 데이터베이스로의 직접 접근이 허용되어서는 안 된다.

 다른 서비스에서 비즈니스 로직에 접근할 수 있도록 웹 인터페이스를 제공해야 한다.

** 관행 45p

 애플리케이션을 운영하는 데 필요한 인프라스트럭처를 프로비저닝(provisioning)해주는 셀프 서비스 인터페이스를 제공한다.

 애플리케이션을 하나의 꾸러미로서 패키징하고 셀프 서비스 인터페이스를 통해 운영 환경에 배포한다.

 데이터베이스를 서비스의 형태로 애플리케이션에 제공하고 셀프 서비스 인터페이스를 통해 프로비저닝한다.

 애플리케이션은 데이터베이스 접근에 필요한 정보는 데이터베이스가 명시적으로 서비스로서 바인딩된 이후에만 외부 변수로서 제공받는다.

 애플리케이션은 자신이 의존하는 외부 서비스의 위치를 파악할 수 있게 해주는 서비스 레지스트리를 제공받는다.
--

 클라우드 네이티브 애플리케이션(Cloud Native Application)은 비즈니스 차별점 창출은 커녕 노력만 많이 드는 작업에 소모되는 시간을 줄여주는 제약 조건을 전제로 만들어진다. 46p

* 패턴 47p
+
----
일체형 애플리케이션의 컴포넌트들을 분해해서 변경 관리를 분산시키면 개발팀은 운영 환경에 기능을 추가하는 데 더 많은 제어권을 갖는다. 개발팀은 컴포넌트 사이의 의존성을 줄이고 격리시키면서 릴리스 주기를 독립적으로 가져갈 수 있는 더 작은 규모의 단일 책임 서비스 개발에 집중한다.
 
격리에 의해 애플리케이션이 점점 더 분산되면 애플리케이션 컴포넌트 간 통신 과정에서 발생할 수 있는 장애가 중요한 이슈가 된다. 47p
----

* 확장성 47p

 운영자와 개발자 간의 의사소통 방식을 성공적으로 개선하려면 더 믿을 만한 소프트웨어 개발 과정, 즉 소프트웨어 개발 프로세스 안에 운영팀의 경험을 녹여 넣고, 서로 배우고 개선하는 방식으로 전환해야 한다. 48p

* 신뢰도 48p

 팀 사이의 서비스 합의를 만드는 목적은 비즈니스에 가치를 더해주는 전체적인 확장 기능이 예상대로 동작하지 않을 위험을 줄이는 것이다. 예상되는 운영 비용에 상응하는 수준의 동작을 보장하기 위해 서비스 합의를 명시적으로 작성한다. 이를 통해 서비스는 각 비즈니스 단위가 가능한 최대의 결과물을 낼 수 있게 해준다. 48p

* 애자일성 49p

 분산 시스템을 개발하는 일은 상당한 복잡성을 감수해야 한다. 그럼에도 소프트웨어 장애 위험은 더 낮추고 소프트웨어를 더 빨리 전달하기 위해 기업 애플리케이션은 분산 애플리케이션 아키텍처로 이동하고 있다. 현대 비즈니스에서는 애플리케이션을 운영 환경에 더 빨리, 지속적으로 전달할 수 있도록 개발 프로세스를 재정립해야 한다. 49p

* 넷플릭스 사례 50p
** 마이크로서비스 53p
+
--
 마이크로서비스 구축에 담긴 핵심 발상은 기능개발팀이 개발 조직을 스스로 구성할 수 있는 권한과 함께, 특정 비즈니스 범위를 담당하는 애플리케이션을 만드는 능력을 갖게 하는 것이다. 사실 이 방식이 특별히 새로운 것은 아니다. 작게 분산되어 알맞게 협업하는 컴포넌트를 모아서 시스템을 만들고, 개별 기능을 운영 환경에 반영할 때 위험을 낮추기 위해 컴포넌트로 쪼개는 방식은 수십년간 이어져온 방식이다. 

----
오늘날 마이크로서비스 아키텍처에서 볼 수 있는 모듈성과 단순성, 느슨한 결합은 제대로 설계된 일체형 애플리케이션에도 그대로 존재한다. 

주요 차이점은 물론 개발 이력이다. 어떠 한 사람이 전체 아키텍처 중에서 교체할 수 있는 일부에 대해 그릇된 선택을 하더라도, 그 일부는 시간이 지남에 따라 쉽게 분해할 수 있다. 하지만 그 사람이 제대로 설계된 일체형 애플리케이션의 여러 모듈을 다루면서 망쳐 놓는다면, 나중에 다른 사람이 바른 선택을 하기 어려워질 수도 있다. 53p
----
--

** 일체형 쪼개기 54p

 소프트웨어 아키텍처의 중앙화 수준이 높아질수록 변경 조정에 더 많은 시간이 들게 된다. 일체형은 하나의 릴리스 주기 안에서 변경이 많이 발생할수록 장애가 발생할 위험도 더 커진다. 일체형을 더 작고 단순한 서비스로 나누면 배포를 더 작은 단위로 수행할 수 있으며, 개발팀은 작은 단위의 릴리스 주기를 독립적으로 가져갈 수 있다. 54p 

* 12요소 방법론 57p
** 핵심사상
+
----
선언적 형식으로 설정을 자동화해서 프로젝트에 새로 참여하는 동료가 적응하는 데 필요한 시간과 비용을 최소화한다.
운영체제에 구애받지 않는 투명한 계약을 통해 다양한 실행 환경에서 작동할 수 있도록 이식성을 극대화한다.
현대적인 클라우드 플랫폼 기반 개발을 통해 서버와 시스템 관리에 대한 부담을 줄인다.
개발과 운영의 간극을 최소화해서 지속적 배포(continuous deployment)를 가능하게 하고 애자일성을 최대화한다.
도구, 아키텍처, 개발 관행을 크게 바꾸지 않아도 서비스 규모 수직적 확장이 가능하다. 57p
----

** 실천법
+
----
코드베이스(Codebase) : 버전 관리되는 하나의 코드베이스가 여러 번 배포된다.

의존관계(Dependencies) : 의존관계는 명시적으로 표시하고 격리한다.

설정(Config) : 설정 정보는 실행 환경에 저장한다.

지원 서비스(Backing services) : 지원 서비스는 필요에 따라 추가되는 자원으로 취급한다.

빌드, 릴리스, 실행(Build, release, run) : 빌드와 릴리스, 실행 단계는 엄격하게 분리한다.

프로세스(Processes) : 애플리케이션은 하나 이상의 무상태 프로세스로 실행한다.

포트 바인딩(Port binding) : 서비스는 포트에 연결해서 외부에 공개한다.

동시성(Concurrency) : 프로세스 모델을 통해 수평적으로 확장한다.

처분성(Disposability) : 빠른 시작과 깔끔한 종료로 견고함을 극대화한다.

개발/운영 짝맞춤(Dev/prod parity) : 개발과 스테이징, 운영은 가능한 한 동일하게 유지한다.

로그(Logs) : 로그는 이벤트 스트림으로 취급한다.

관리 프로세스(Admin Process) : 관리(admin/management) 작업은 일회성 프로세스로 실행한다. 58p
----

** 코드베이스

 버전 관리되는 하나의 코드베이스가 여러번 배포된다.

** 의존관계

 의존관계는 명시적으로 표시하고 격리한다.

** 설정

 설정 정보는 실행 환경에 저장한다.

** 지원 서비스

 지원 서비스는 필요에 따라 추가되는 자원으로 취급한다.

** 빌드, 릴리스, 실행

 빌드와 릴리스, 실행 단계는 엄격하게 분리한다.
+
----
빌드단계 : 애플리케이션 소스 코드를 가져와서 필요하다면 컴파일을 한 후에 하나의 패키지로 만든다. 이렇게 만들어진 패키지를 빌드(build)라고 한다.

릴리스 단계 : 릴리스(release) 단계는 빌드에 환경설정 정보를 조합한다. 배포를 위해 생성된 릴리스 버전은 실행환경에서 운영될 수 있는 준비가 완료되어 있으며, 시맨틱 버저닝(semantic versioning) 또는 타임스탬프를 통해 유일한 식별자가 부여된다. 릴리스 버전은 특정 디렉토리에 저장되어 나중에 릴리스 관리 도구를 통해 이전 버전으로 롤백하는 데 사용된다.

실행 단계 : 실행(run) 단계는 보통 런타임이라고 불리기도 하는데, 릴리스 버전 중에 하나를 선택해서 실행 환경 위에서 애플리케이션을 실행한다.
----

** 프로세스

 애플리케이션은 하나 이상의 무상태 프로세스로 실행한다.

** 포트 바인딩

 서비스는 포트에 연결해서 외부에 공개한다.

** 동시성

 프로세스 모델을 통해 수평적으로 확장한다.

** 처분성

 빠른 시작과 깔끔한 종료로 견고함을 극대화한다.

** 개발/운영 짝맞춤

 개발, 스테이징, 운영은 가능한 한 동일하게 유지한다.

** 로그

 로그는 이벤트 스트림으로 취급한다.

** 관리 프로세스

 관리(admin/management) 작업을 일회성 프로세스로 실행한다.



[[Chapter2_부트캠프:_스프링부트와_클라우드_파운드리_소개]]
== 부트캠프: 스프링 부트와 클라우드 파운드리 소개
* 설정 87p
** {blank}
+
 정적 변수(static variables)에 담을 수도 있지만 그렇게 하면 정적 참조가 난무할 테고 결국 테스트하기 어려워진다. 정적 참조의 목(mock)은 또 어떻게 만들까? 데이터소스 참조를 JNDI(Java Naming and Directory Interface) 같은 공유 컨텍스트에 저장할 수도 있지만 JNDI의 목을 만드는 것이 어려워서 테스트하기 곤란해지긴 마찬가지다. 89p

** {blank}
+
 컴포넌트가 의존하는 특정 클래스가 어디에서 어떻게 생성되는지 모르게 하면 단위 테스트를 할 때 가짜 목 객체를 주입할 수 있다. 89p

** {blank}
+
 스프링은 스프링 자체를 변경하지 않고도 애플리케이션에 커스텀 기능을 추가할 수 있도록 서비스 로더(service loader) 개념을 지원한다. 커스텀 기능은 META-INF/spring.factories 파일에 등록할 수 있다. 스프링 부트는 spring.factories 파일을 읽어서 org.springframework.boot.autoconfigure.EnableAutoConfiguration에 의해 로딩되는 모든 클래스를 찾는다. 스프링 부트 프레임워크에 들어 있는 spring-boot-autoconfiguration.jar 파일에는 수십 가지의 설정 클래스가 포함되어 있다. 99p

* 클라우드 파운드리 103p
** {blank}
+
----
 우리의 목표는 애플리케이션을 운영 환경과 비슷한 환경에 지속적으로 배포하고 통합 테스트(integration test)와 인수 테스트(acceptance test)를 거쳐서 운영 환경에 배포되었을 때 정상적으로 동작할 수 있는지 검증하는 것이다. 고객은 운영 환경에서만 애플리케이션의 정상 동작을 확인할 수 있으므로, 애플리케이션을 운영 환경에 자주 배포하는 것이 중요하다.
 
 배포를 자주해서 하나의 배포에 포함되는 변경의 양을 적게 가져가야 한다. 배포 후 문제가 발생하면 변경 내용만 수정해서 다시 올리면 되는데, 변경의 양 자체가 적으므로 수정 및 재배포에 드는 노력도 줄일 수 있다.
 
 배포는 비지니스 차별화를 이끌어내는 작업이 아니다. 따라서 배포 작업은 자동화해서 속도를 높여야 한다. 103p
----

** {blank}
+
----
 리액터 API를 쓰면 병렬성(parallelization)을 다루는 코드를 작성하지 않고도 병렬성의 장점을 이용할 수 있다. 리액터의 목표는 과도한 자원 사용을 피하고 클라우드 기반의 작업 부하에서 블로킹 부분을 효율적인 방식으로 격리시키는 것이다.
 
 리액티브 스트림에는 구독자(subscriber)가 발행자(publisher)에게 더 이상 정보를 받고 싶지 않다는 신호를 보낼 수 있는 배압(backpressure)라는 개념이 있다. 구독자가 수동적으로 받기만 하는 것이 아니라 발행자에게 푸시 방식으로 정보를 보내서 스스로 감당할 수 있는 만큼의 정보만 조절해서 받을 수 있다. 109p
----


